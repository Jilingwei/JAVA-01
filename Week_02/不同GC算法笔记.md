## 不同GC算法笔记

## 标记清除算法

1. 算法介绍

   标记清除法是现在GC算法的基础，目前似乎没有哪个GC还在使用这种算法了。因为这种算法会产生大量的内存碎片。

   标记清除算法的执行过程分为两个阶段：标记阶段、清除阶段。

   - 标记阶段会通过可达性分析将不可达的对象标记出来。
   - 清除阶段会将标记阶段标记的垃圾对象清除。

<img src="https://user-gold-cdn.xitu.io/2019/1/18/16861367f77c6c99?imageslim" alt="img" style="zoom:80%;" />

2. 算法特点

   该算法存在明显的缺点，回收后会产生大量不连续的内存空间，即内存碎片。由于Java在分配内存时通常是按连续内存分配，那么当碎片空间不足以分配给新的对象时，就造成了内存浪费。

## 复制算法

1. 算法介绍

   复制算法会将内存空间分为两块，每次只使用其中一块内存。复制算法同样使用可达性分析法标记除垃圾对象，当GC执行时，会将非垃圾对象复制到另一块内存空间中，并且保证内存上的连续性，然后直接清空之前使用的内存空间。然后如此往复。

   我们姑且将这两块内存区域称为from区和to区。

   如下图所示，r1和r2作为GC Root对象，经过可达性分析后，标记除黄色对象为垃圾对象。

   

   ![img](https://user-gold-cdn.xitu.io/2019/1/18/1686137101be3578?imageslim)

   

   复制过程如下，GC会将五个存活对象复制到to区，并且保证在to区内存空间上的连续性。

   ![img](https://user-gold-cdn.xitu.io/2019/1/18/168613745047ce7d?imageslim)

   最后，将from区中的垃圾对象清除。

   ![img](https://user-gold-cdn.xitu.io/2019/1/18/16861376a249d525?imageslim)

   2. 算法特点

      该算法在存货对象少，垃圾对象多的情况下，非常高效。其好处是不会产生内存碎片，但坏处也是显而易见的，就是直接损失了一半的可用内存。

   ## 标记压缩法

   1. 算法介绍

      标记压缩法主要分成三个步骤

      + 标记垃圾对象
      + 清除垃圾对象
      + 内存碎片处理

      过程如下：

      首先标记除垃圾对象（黄色）

      ![img](https://user-gold-cdn.xitu.io/2019/1/18/1686137e796cb5c9?imageslim)

      清除垃圾对象

      ![img](https://user-gold-cdn.xitu.io/2019/1/18/1686139f6a37c8fc?imageslim)

      内存碎片整理

      ![img](https://user-gold-cdn.xitu.io/2019/1/18/168613a4abc51785?imageslim)

      2. 算法特点

         该算法的特点在于，内存的使用率比复制发更高，但是需要花时间再整理内存碎片上。

      ## 分代算法

      分代算法基于复制算法和标记压缩算法。

      首先，标记清除算法、复制算法、标记压缩算法都有各自的缺点，如果单独用其中某一算法来做GC，会有很大的问题。

      例如，标记清除算法会产生大量的内存碎片，复制算法会损失一半的内存，标记压缩算法的碎片整理会造成较大的消耗。

      其次，复制算法和标记压缩算法都有各自适合的使用场景。

      复制算法适用于每次回收时，存活对象少的场景，这样就会减少复制量。

      标记压缩算法适用于回收时，存活对象多的场景，这样就会减少内存碎片的产生，碎片整理的代价就会小很多。

      分代算法将内存区域分为两部分：新生代和老年代。

      根据新生代和老年代中对象的不同特点，使用不同的GC算法。

      新生代对象的特点是：创建出来没多久就可以被回收（例如虚拟机栈中创建的对象，方法出栈就会销毁）。也就是说，每次回收时，大部分是垃圾对象，所以新生代适用于复制算法。

      老年代的特点是：经过多次GC，依然存活。也就是说，每次GC时，大部分是存活对象，所以老年代适用于标记压缩算法。

      新生代分为eden区、from区、to区，老年代是一整块内存空间，如下所示：

      

      
      

   